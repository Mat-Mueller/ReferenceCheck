<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Text Selection and CrossRef Search</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            background-color: #f9f9f9;
            color: #333;
        }
        .search-string-frame, .result-frame {
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
            background-color: #f0f0f0;
        }

            .search-string-frame p, .result-frame p {
                margin: 0;
                font-size: 16px;
            }
        #controls img {
            height: 40px; /* Adjust size as needed to match button height */
            
            margin-right: 10px;
        }

        #controls {
            padding: 15px;
            background: #4a90e2;
            color: #fff;
            
            border-bottom: 1px solid #ccc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

            #controls button, #controls input[type="file"], #controls select {
                margin-left: 10px;
                padding: 10px 15px;
                width: 190px;
                background-color: #fff;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                color: #333;
            }

                #controls button.active {
                    background-color: #333;
                    color: #fff;
                }

        #viewer {
            display: flex;
            flex: 1;
            overflow-y: hidden;
        }

        #left-column {
            width: 60px;
            background-color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-right: 1px solid #ccc;
        }

        .frame {
            width: 50%;
            height: 100%;
            overflow-y: auto;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin: 10px;
            background-color: #fff;
            border-radius: 5px;
        }

        .textLayer {
            position: relative;
            pointer-events: auto;
            display: block;
        }

        .highlight {
            
            z-index: 1000;
        }

        .textLayer > div {
            position: absolute;
            transform-origin: 0% 0%;
        }

        .textLayer .endOfContent {
            display: none;
        }

        .result-item {
            margin-bottom: 20px;
        }

            .result-item p {
                margin: 0;
            }

        .active {
            background-color: #ccc; /* Active button style */
        }
    </style>
</head>
<body>
    <div id="controls">
        <img src="Logo.png" alt="Icon" id="icon">
        <input type="file" id="pdf-upload" accept="application/pdf">
        <select id="separationCriteria">
            <option value="" disabled selected>Separation Criteria:</option>
            <option value="byYear">By Year</option>
            <option value="byParagraph">By Paragraph</option>
            <option value="byIndent">By Indent</option>
            <option value="None">None</option>
        </select>

        <select id="selectionMode">
            <option value="" disabled selected>Reference Section:</option>
            <option value="byTitle">By Headline</option>
            <option value="manual">Manual Select</option>
            <option value="clickSelect">Start/End Select</option>
        </select>




        <button id="crossref-button">Crossref Search</button>
        <!--<button onclick="clearPDFAndReload()">Reload Page</button>-->
        <div id="notification" style="
    
        margin-top: 10px;
        
        border: 2px solid white;
        width: 300px; /* Fixed width */
        padding: 10px; /* Padding inside the box */
        text-align: center;
    ">Hier Kann Text Stehen</div>
    </div>
    <div id="viewer">

        <div class="frame" id="pdf-container"></div>
        <div class="frame" id="scholar-container">
            <!-- Results will be displayed here -->
        </div>
    </div>

    <!-- PDF.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="script.js"></script>


    <script>
        const pdfjsLib = window['pdfjs-dist/build/pdf'];
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';

        const pdfContainer = document.getElementById('pdf-container');
        let pdfDocument = null;
        let searchMode = 'automatic'; // Initial search mode

        function clearPDFAndReload() {
            const pdfContainer = document.getElementById('pdf-container');
            pdfContainer.innerHTML = ''; // Clear the PDF container

            window.location.reload(true); // Reload the page from the server
        }

        function LoadScholar() {


            // Encode the query to be URL-safe
            const encodedQuery = encodeURIComponent(getSelectedText());
            // Construct the Google Scholar search URL
            const url = `https://scholar.google.com/scholar?q=${encodedQuery}`;
            // Open a new window with the constructed URL
            window.open(url, '_blank');

        }


        document.getElementById('pdf-upload').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
                const fileURL = URL.createObjectURL(file);
                loadPDF(fileURL);
            }
        });

        function loadPDF(url) {
            pdfjsLib.getDocument(url).promise.then(function (pdf) {
                pdfDocument = pdf;
                document.getElementById('pdf-container').innerHTML = ''; // Clear previous content
                renderAllPages();
                removeEmptyDivs()
            });
        }

        function analyzePageForThreshold(page) {
            return page.getTextContent().then(function (textContent) {
                let yDiffs = [];

                let prevY = null;
                textContent.items.forEach(function (textItem) {
                    const currentY = textItem.transform[5];
                    if (prevY !== null) {
                        const yDiff = Math.abs(currentY - prevY);
                        yDiffs.push(yDiff);
                        console.log(yDiff)
                        console.log(textItem)
                    }
                    prevY = currentY;
                });

                // Find the most common y-difference
                return findMostFrequentValue(yDiffs);
            });
        }

        function findMostFrequentValue(arr) {
            const frequencyMap = {};
            let maxFrequency = 0;
            let mostFrequentValue = null;

            arr.forEach(value => {
                if (value in frequencyMap) {
                    frequencyMap[value]++;
                } else {
                    frequencyMap[value] = 1;
                }
                if (frequencyMap[value] > maxFrequency) {
                    maxFrequency = frequencyMap[value];
                    mostFrequentValue = value;
                }
            });

            return mostFrequentValue + 1;
        }

        function renderAllPages() {
            for (let pageNum = 1; pageNum <= pdfDocument.numPages; pageNum++) {
                pdfDocument.getPage(pageNum).then(function (page) {
                    const viewport = page.getViewport({ scale: 1.5 });
                    const textLayerDiv = document.createElement('div');
                    textLayerDiv.className = 'textLayer';
                    textLayerDiv.style.height = `${viewport.height}px`;
                    textLayerDiv.style.width = `${viewport.width}px`;
                    textLayerDiv.style.position = 'relative';
                    textLayerDiv.style.marginBottom = '5px'; // Space between pages
                    textLayerDiv.style.overflow = 'hidden'; // Hide overflow content

                    pdfContainer.appendChild(textLayerDiv);

                    page.getTextContent().then(function (textContent) {
                        let lines = []; // Array to store lines with their Y coordinate

                        textContent.items.forEach(function (textItem) {
                            const currentY = textItem.transform[5]; // Y coordinate
                            const currentX = textItem.transform[4]; // X coordinate
                            const lineText = textItem.str;
                            const fontSize = textItem.transform[0]; // Extract font size
                            const fontName = textItem.fontName; // Extract font name (for bold, italic, etc.)

                            let line = lines.find(line => Math.abs(line.y - currentY) < 2); // Find line with a similar Y coordinate

                            if (!line) {
                                line = {
                                    text: '',
                                    x: currentX,
                                    y: currentY,
                                    fontSize: fontSize, // Store font size for the line
                                    fontName: fontName // Store font name for the line
                                };
                                lines.push(line);
                            }

                            line.text += lineText + ' '; // Concatenate text on the same line
                        });

                        // Sort lines by their Y coordinate (descending order)
                        lines.sort((a, b) => b.y - a.y);

                        // Render all lines
                        lines.forEach(function (line) {
                            const lineElement = document.createElement('div');
                            lineElement.textContent = line.text.trim(); // Remove any trailing space
                            lineElement.className = 'textLine';
                            lineElement.style.position = 'absolute';
                            lineElement.style.whiteSpace = 'pre'; // Preserve whitespace
                            lineElement.style.left = `${line.x}px`; // Set X position based on the first text item
                            lineElement.style.top = `${(viewport.height - line.y * 1.5)}px`; // Set Y position (inverted)
                            lineElement.style.margin = '0'; // Ensure no margin is added
                            lineElement.style.padding = '0'; // Ensure no padding is added

                            // Apply font size and font weight (bold) if applicable
                            lineElement.style.fontSize = `${line.fontSize}px`; // Set font size
                            if (line.fontName && line.fontName.toLowerCase().includes('bold')) {
                                lineElement.style.fontWeight = 'bold'; // Set bold style if the font name contains "bold"
                            }

                            textLayerDiv.appendChild(lineElement);
                        });
                    });
                });
            }
        }






        function processParagraph(container, text) {
            const p = document.createElement('p');
            p.textContent = text;
            p.style.margin = '0';
            container.appendChild(p);
        }




        function removeEmptyDivs() {
            const textLayerDivs = pdfContainer.querySelectorAll('.textLayer');
            textLayerDivs.forEach(div => {
                if (!div.textContent.trim()) {
                    div.remove();
                }
            });
        }




        function getSelectedText() {
            let text = '';
            if (window.getSelection) {
                const selection = window.getSelection();
                text = selection.toString();
            } else if (document.selection && document.selection.type != "Control") {
                text = range.text;
            }
            return text.trim();
        }



        ////// Functions to select potential References /////////////

        document.addEventListener("DOMContentLoaded", () => {
            let highlightCounter = 0; // Counter for unique IDs
            let isSelecting = false;
            let startContainer, startOffset;

            document.addEventListener("mouseup", function (e) {
                const selectionMode = document.getElementById('selectionMode').value;

                
                if (selectionMode === 'manual' || selectionMode === 'automatic') {
                    Sudivide(window.getSelection());
                }
                
            });

            document.addEventListener("click", function (e) {
                const selectionMode = document.getElementById('selectionMode').value;
                const frame = document.getElementById('pdf-container'); // Get the frame element

                // Check if the click is within the frame
                if (selectionMode === 'clickSelect' && frame.contains(e.target)) {
                    if (!isSelecting) {
                        // First click: Set the start of the selection (find nearest div below)
                        isSelecting = true;
                        const nearestDiv = findNearestTextDivBelow(e.clientX, e.clientY);
                        if (nearestDiv) {
                            startContainer = nearestDiv;
                            startOffset = 0; // Start from the beginning of the div
                            console.log("Selection started at div:", startContainer);
                        }
                    } else {
                        // Second click: Set the end of the selection (find nearest div above)
                        isSelecting = false;
                        const nearestDiv = findNearestTextDivAbove(e.clientX, e.clientY);

                        const selection = window.getSelection();
                        const range = document.createRange();
                        if (startContainer && nearestDiv) {
                            range.setStart(startContainer.firstChild || startContainer, startOffset);
                            range.setEnd(nearestDiv.firstChild || nearestDiv, nearestDiv.textContent.length);

                            selection.removeAllRanges();
                            selection.addRange(range);

                            // Process the selected range
                            if (searchMode == 'manual') {
                                Make_Reference(selection);
                            }
                            if (searchMode == 'automatic') {
                                Sudivide(selection);
                            }

                            console.log("Selection completed", selection.toString());
                            document.getElementById('selectionMode').value = '';
                        } else {
                            console.log("Invalid selection; could not find valid start or end container.");
                        }
                    }
                }
            });


            function findNearestTextDivBelow(x, y) {
                const divs = pdfContainer.querySelectorAll('div.textLine'); // Only target divs with the 'textLine' class
                let nearestDiv = null;
                let nearestDistance = Infinity;

                divs.forEach(div => {
                    const rect = div.getBoundingClientRect();
                    const divY = rect.top;  // Use the top of the div

                    if (divY >= y) {  // Only consider divs below the click point
                        const distance = Math.abs(divY - y);

                        if (distance < nearestDistance && div.textContent.trim().length > 0) {
                            nearestDistance = distance;
                            nearestDiv = div;
                        }
                    }
                });

                return nearestDiv;
            }

            function findNearestTextDivAbove(x, y) {
                const divs = pdfContainer.querySelectorAll('div.textLine'); // Only target divs with the 'textLine' class
                let nearestDiv = null;
                let nearestDistance = Infinity;

                divs.forEach(div => {
                    const rect = div.getBoundingClientRect();
                    const divY = rect.bottom;  // Use the bottom of the div

                    if (divY <= y) {  // Only consider divs above the click point
                        const distance = Math.abs(divY - y);

                        if (distance < nearestDistance && div.textContent.trim().length > 0) {
                            nearestDistance = distance;
                            nearestDiv = div;
                        }
                    }
                });
                console.log(nearestDiv)
                return nearestDiv;
            }

            const selectionMode = document.getElementById('selectionMode');

            // Add event listener for change on the select element
            selectionMode.addEventListener('change', function () {
                const selectedValue = selectionMode.value;

                // Check if "byTitle" is selected
                if (selectedValue === 'byTitle') {
                    // Do something when "byTitle" is selected
                    console.log('byTitle selected! Performing action...');

                    // Reset the select element back to its default option
                    const titles = [
                        'references',
                        'références',
                        'rÉférences',
                        'r´ef´erences',
                        'bibliography',
                        'bibliographie',
                        'literaturverzeichnis',
                        'citations',
                        'refs',
                        'publications',
                        'réfs',
                        'rÉfs',
                        'reference',
                        'référence',
                        'rÉférence'
                    ];

                    function findReferenceSection() {
                        const divs = document.querySelectorAll('div.textLine'); // Get all div elements with class "textLine"
                        let startPoint = null;

                        // Iterate through all divs to find the start of the reference section
                        for (let i = 0; i < divs.length; i++) {
                            const divText = divs[i].textContent.trim().toLowerCase(); // Get the text and convert to lowercase

                            // Check if any of the keywords matches the div text
                            if (titles.some(title => divText === title.toLowerCase())) {
                                console.log('Reference section found at div index:', i);
                                console.log('Text:', divs[i].textContent.trim());

                                // Set the start point of the reference section
                                startPoint = divs[i + 1];
                                startFontSize = window.getComputedStyle(divs[i]).fontSize;
                                normalFontSize = window.getComputedStyle(startPoint).fontSize;
                                console.log(startFontSize)
                                console.log(normalFontSize)
                                // Optionally, highlight the start of the reference section
                                startPoint.style.backgroundColor = 'yellow'; // Highlight the start of the reference section

                                break; // Stop after finding the first match
                            }
                        }

                        if (startPoint) {
                            let endPoint = null
                            if (startFontSize > normalFontSize) {

                                
                                for (let i = Array.from(divs).indexOf(startPoint) + 1; i < divs.length; i++) {
                                    const currentFontSize = window.getComputedStyle(divs[i]).fontSize;

                                    // If we find a div with the same font size as startFontSize, set it as the endPoint
                                    if (currentFontSize === startFontSize) {
                                        endPoint = divs[i - 1];
                                        console.log('Found matching font size div at index:', i);
                                        break;
                                    }
                                }


                                
                            } 


                            if (!endPoint) {
                                endPoint = divs[divs.length - 1]; // Last div element
                                console.log('No matching font size found, reference section ends at the last div.');
                            }
                                // Assume the last div in the document is the end of the reference section
                                console.log('Reference section ends at the last div.');

                                // Create a Range and Selection for the reference section
                                const range = document.createRange();
                                const selection = window.getSelection();

                                // Set the start of the range at the first child of the start div
                                range.setStart(startPoint.firstChild || startPoint, 0);

                                // Set the end of the range at the last child of the last div
                                range.setEnd(endPoint.lastChild || endPoint, endPoint.textContent.length);

                                // Clear existing selections
                                selection.removeAllRanges();

                                // Add the newly created range to the selection
                                selection.addRange(range);

                                // Call the Sudivide function with the selection
                                Sudivide(selection);
                            
                        } else {
                            console.log('Reference section not found.');
                        }
                    }


                    // Call the function to find the reference section
                    findReferenceSection();

                    // Reset the select element back to its default option
                    selectionMode.selectedIndex = 0;
                
                }
            });


            ///////////   JZjzgkjulewileiwfi /////////////


            // Add event listener for clicks on spans with class 'highlight'
            document.addEventListener('click', function (e) {
                if (e.target && e.target.matches('div.highlight')) {  // Adjusted to handle 'div.highlight' 
                    // Get necessary attributes from the clicked div
                    const divId = e.target.getAttribute('MyId');  // Getting the ID of the clicked div
                    const query = getMergedTextByMyId(divId);
                    let dataResults = e.target.getAttribute('data-results');  // Fetching the data-results attribute

                    console.log('Query:', query);
                    console.log('MyId:', divId);

                    // If dataResults is not defined, make it an empty object "{}"
                    if (!dataResults) {
                        dataResults = '{}';  // Treat as an empty object
                    }

                    try {
                        // Parse the data-results as JSON
                        const data = JSON.parse(dataResults);

                        // Check if data is valid (if data.message.items exists)
                        if (data && data.message && data.message.items) {
                            displaySearchResults(data, query, divId);  // Display the search results
                        } else {
                            console.log('No valid results to display for div ID:', divId);
                            displaySearchResults({}, query, divId);  // Display empty results
                        }
                    } catch (error) {
                        console.error('Error parsing data for div ID:', divId, error);
                    }
                }
            });


            function delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }


            function Sudivide(selection) {
                console.log("subdivide")
                if (!selection.isCollapsed) {
                    // Get the selected criterion for separation
                    const selectedCriterion = document.getElementById('separationCriteria').value;
                    // Get the selected mode for reference section
                    //const selectedMode = document.getElementById('selectionMode').value;

                    for (let i = 0; i < selection.rangeCount; i++) {
                        const range = selection.getRangeAt(i);

                        const container = range.commonAncestorContainer;
                        const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
                            acceptNode: function (node) {
                                return NodeFilter.FILTER_ACCEPT;
                            }
                        });

                        let node;
                        let pElements = [];

                        while (node = walker.nextNode()) {
                            if (node.nodeName === 'DIV' && range.intersectsNode(node)) {
                                if (node.classList.contains('textLine')) { // Filter to only include textLine elements
                                    pElements.push(node);
                                }
                            }
                        }

                        // If the selection mode is "manual", we don't subdivide at all
                        if (selectedCriterion === 'None') {
                            let mergedContent = "";
                            for (let j = 0; j < pElements.length; j++) {
                                mergedContent += " " + pElements[j].textContent.trim();
                                pElements[j].setAttribute("myID", highlightCounter);
                                pElements[j].style.backgroundColor = '#add8e6';
                                pElements[j].classList.add('highlight');
                            }
                            Make_Reference(highlightCounter, pElements);
                            highlightCounter++;
                            continue; // Skip to the next range if in manual mode
                        }






                        // Calculate distances between consecutive DIVs if "byParagraph" is selected
                        let distances = [];
                        if (selectedCriterion === 'byParagraph') {
                            for (let j = 0; j < pElements.length - 1; j++) {
                                const currentRect = pElements[j].getBoundingClientRect();
                                const nextRect = pElements[j + 1].getBoundingClientRect();
                                const distance = nextRect.top - currentRect.bottom;
                                const roundedDistance = Math.round(distance * 10) / 10; // Round to one decimal place
                                distances.push(roundedDistance);
                            }
                        }

                        // Find the most common distance
                        const mostCommonDistance = findMostCommonDistance(distances);

                        let mergedContent = "";
                        const yearRegex = /(?<=^|\s|\()(19[4-9]\d|20[0-2]\d|2030)(?=$|\s|\)|\.|,)/;
                        let counter = [];
                        const firstRect = pElements[0].getBoundingClientRect();
                        for (let j = 0; j < pElements.length; j++) {
                            mergedContent += " " + pElements[j].textContent.trim();
                            pElements[j].setAttribute("myID", highlightCounter);
                            pElements[j].style.backgroundColor = '#add8e6';
                            pElements[j].classList.add('highlight');
                            counter.push(j);

                            // Separation logic based on the selected criterion
                            let shouldSeparate = false;

                            if (selectedCriterion === 'byYear') {
                                if (yearRegex.test(pElements[j + 1]?.textContent) || j == pElements.length - 1) {
                                    shouldSeparate = true;
                                }
                            } else if (selectedCriterion === 'byParagraph') {
                                const currentRect = pElements[j].getBoundingClientRect();
                                const nextRect = pElements[j + 1]?.getBoundingClientRect();
                                console.log(distances)
                                console.log(mostCommonDistance)

                                if (nextRect && (nextRect.top - currentRect.bottom > mostCommonDistance + 1) || j == pElements.length - 1) {
                                    shouldSeparate = true;
                                }
                            } else if (selectedCriterion === 'byIndent') {
                                const currentRect = pElements[j].getBoundingClientRect();
                                // Get the left position of the first div as the reference for non-indented divs
                                const nextRect = pElements[j + 1]?.getBoundingClientRect();

                                
                                if (nextRect && (Math.round(nextRect.left * 10) / 10 < Math.round(currentRect.left * 10) / 10) || j == pElements.length - 1) {
                                    shouldSeparate = true;
                                }

                                
                            }

                            if (shouldSeparate) {
                                //Make_Reference(highlightCounter, pElements);
                                
                                counter = [];
                                


                                highlightCounter++;
                                //await delay(2000); // Optional delay for any async tasks like highlighting
                            }
                        }
                        const notificationElement = document.getElementById('notification');
                        notificationElement.textContent = `Found ${highlightCounter} References` ;
                    }
                }
            }




            // Function to find the most common distance
            function findMostCommonDistance(distances) {
                if (distances.length === 0) return 0;

                // Count occurrences of each distance
                const distanceCount = distances.reduce((acc, dist) => {
                    acc[dist] = (acc[dist] || 0) + 1;
                    return acc;
                }, {});

                // Get the unique distances sorted by frequency and value
                const sortedDistances = Object.entries(distanceCount)
                    .sort((a, b) => b[1] - a[1] || a[0] - b[0]) // Sort by frequency, then by distance value
                    .map(([dist, count]) => ({ dist: parseFloat(dist), count })); // Convert the distances back to numbers

                // If there are more than two unique distances, reduce to the two most frequent
                if (sortedDistances.length > 2) {
                    sortedDistances.length = 2; // Keep only the top two most frequent distances
                }

                // From the remaining distances, return the smallest
                return Math.min(sortedDistances[0].dist, sortedDistances[1].dist);
            }





  

            function Make_Reference(highlightCounter, pElements) {
                // Loop through the array of pElements (div elements)


                // Optionally trigger further actions with the highlightCounter
                triggerSearch(highlightCounter); // Assuming this handles all the highlighted divs
            }


            document.getElementById('crossref-button').addEventListener('click', CrossrefSearch);
            function delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // Updated CrossrefSearch function to introduce a delay between each call
            async function CrossrefSearch() {
                for (let j = 0; j < highlightCounter; j++) {
                    triggerSearch(j);
                    await delay(2000); // Wait for 2 seconds before the next call
                }
            }
            function getMergedTextByMyId(MyId) {
                const divs = document.querySelectorAll(`[MyId="${MyId}"]`);
                let mergedText = '';
                divs.forEach(div => {
                    mergedText += div.textContent.trim() + ' ';
                });
                return mergedText.trim();
            }

            function triggerSearch(MyId) {
                const mergedText = getMergedTextByMyId(MyId);
                console.log(mergedText);

                // Select all div elements with the specified MyId attribute
                const divs = document.querySelectorAll(`[MyId="${MyId}"]`);

                if (mergedText.length > 0) {
                    document.body.style.cursor = 'wait'; // Change cursor to wait
                    const query = encodeURIComponent(mergedText);
                    const apiUrl = `https://api.crossref.org/works?query.bibliographic=${query}&rows=3`;

                    fetch(apiUrl)
                        .then(response => response.json())
                        .then(data => {
                            displaySearchResults(data, query, MyId);

                            // Set data-results attribute for all matching divs
                            divs.forEach(div => {
                                div.setAttribute('data-results', JSON.stringify(data));
                                div.setAttribute('query', query);
                                div.setAttribute('MyId', MyId);
                            });

                            document.body.style.cursor = 'default'; // Revert cursor to default
                        })
                        .catch(error => {
                            console.error('Error fetching CrossRef data:', error);
                            document.body.style.cursor = 'default'; // Revert cursor to default even if there's an error
                        });
                } else {
                    alert('No text found in the selected divs.');
                }
            }

            function displaySearchResults(data, query, spanId) {
                const scholarContainer = document.getElementById('scholar-container');
                scholarContainer.innerHTML = ''; // Clear previous content

                // Create a frame for the search string
                const searchStringFrame = document.createElement('div');
                searchStringFrame.className = 'search-string-frame';

                // Create a paragraph element to display the search string
                const searchStringParagraph = document.createElement('p');
                searchStringParagraph.innerHTML = `<strong>Search String:</strong> ${decodeURIComponent(query)}`;
                searchStringFrame.appendChild(searchStringParagraph);

                // Create a button to search on Google Scholar
                const searchButton = document.createElement('button');
                searchButton.textContent = 'Search on Google Scholar';

                // Add margin to move the button slightly down from the search string
                searchButton.style.margin = '10px 0 0 10px'; // Top margin of 10px to move it down, and left margin of 10px for spacing

                // Set up the click event to open Google Scholar search
                searchButton.onclick = function () {
                    const cleanedQuery = decodeURIComponent(query).replace(/%2C/g, ','); // Replace encoded commas with actual commas
                    const scholarSearchURL = `https://scholar.google.com/scholar?q=${encodeURIComponent(cleanedQuery)}`;
                    window.open(scholarSearchURL, '_blank'); // Open the URL in a new tab
                };

                // Append the button to the search string frame
                searchStringFrame.appendChild(searchButton);

                // Append the search string frame to the container
                scholarContainer.appendChild(searchStringFrame);

                if (data && data.message && data.message.items && data.message.items.length > 0) {
                    const results = data.message.items.slice(0, 3); // Limit to first 3 results

                    let highestMatch = 0;
                    results.forEach(item => { //// sort based on match
                        if (item.title && item.URL) { // Check if title and URL are present
                            const resultFrame = document.createElement('div');
                            resultFrame.className = 'result-frame';
                            resultFrame.style.backgroundColor = "#FFFFFF";

                            // Format authors
                            const formattedAuthors = formatAuthors(item.author);

                            // Create a single paragraph element
                            const resultParagraph = document.createElement('p');
                            resultParagraph.style.fontSize = '16px'; // Set font size
                            resultParagraph.style.backgroundColor = "#FFFFFF";
                            const matchPercentage = calculateMatchPercentage(item, query);

                            // Construct the inner HTML content with clickable DOI and empty spaces as separators
                            resultParagraph.innerHTML = `<strong>${matchPercentage}% Match</strong>.
         ${formattedAuthors}
         (${getYear(item.issued)}).
         ${item.title[0]}</strong>.
         ${item['container-title'] ? item['container-title'][0] : 'Unknown Journal'}
         DOI: <a href="${item.URL}" target="_blank">${item.DOI}</a>`;

                            resultFrame.appendChild(resultParagraph); // Append the combined paragraph to resultFrame

                            // Add empty line between results
                            resultFrame.style.marginBottom = '20px';

                            scholarContainer.appendChild(resultFrame);

                            // Highlight corresponding span based on match percentage
                            highlightSpan(spanId, matchPercentage);

                            if (highestMatch < matchPercentage) { highestMatch = matchPercentage }
                        }
                    });

                    highlightSpan(spanId, highestMatch);

                    if (scholarContainer.children.length === 0) {
                        const noResultsMsg = document.createElement('p');
                        noResultsMsg.textContent = 'No results found.';
                        scholarContainer.appendChild(noResultsMsg);
                    }
                } else {
                    const noResultsMsg = document.createElement('p');
                    noResultsMsg.textContent = 'No results found.';
                    scholarContainer.appendChild(noResultsMsg);

                    // Create the button to retry the search
                    const retryButton = document.createElement('button');
                    retryButton.textContent = 'Retry CrossRef Search';
                    retryButton.style.marginTop = '5px'; // Add some space above the button

                    // Set up the click event to trigger TriggerSearch()
                    retryButton.onclick = function () {
                        triggerSearch(spanId); // Call TriggerSearch with the query
                    };

                    // Append the retry button to the container
                    scholarContainer.appendChild(retryButton);
                }
            }






            function highlightSpan(MyId, matchPercentage) {
                // Select all div elements with the specified MyId attribute
                const divs = document.querySelectorAll(`[MyId="${MyId}"]`);

                if (divs.length > 0) {
                    // Calculate hue value based on match percentage
                    const hue = (matchPercentage / 100) * 120; // Hue ranges from 0 (green) to 120 (red)

                    // Apply the background color to each matching div
                    divs.forEach(div => {
                        div.style.backgroundColor = `hsl(${hue}, 100%, 50%)`;
                    });
                }
            }


            function calculateMatchPercentage(item, query) {
                // Decode the query string first
                query = decodeURIComponent(query);

                // Weights for different components
                let title_weight = 45;
                let author_weight = 30;
                let journal_weight = 10;
                let year_weight = 10;
                let doi_weight = 5;

                // Format the authors and other components
                const formattedAuthors = formatAuthors(item.author);
                const title = `$${formattedAuthors}
                             (${getYear(item.issued)}).
                             <strong><a href="${item.URL}" target="_blank">${item.title[0]}</a></strong>.
                             ${item['container-title'] ? item['container-title'][0] : 'Unknown Journal'}
                             DOI: ${item.DOI}`;

                // Clean and split title words
                const titleWords = item.title[0].replace(/[^\w\s]/gi, '').toLowerCase().split(/\s+/);

                // Split decoded query into lowercase words
                var queryWords = query.replace(/[^\w\s]/gi, '').toLowerCase().split(/\s+/);
                queryWords = queryWords.filter((element) => {
                    return element.length > 1;
                });
                const queryWordSet = new Set(queryWords);

                // Clean and split author surnames
                let authorSurnames = formatAuthors_Surname(item.author).replace(/[^\w\s]/gi, '').toLowerCase().split(/\s+/);

                // Clean and split journal name
                let journalWords = item['container-title'] ? item['container-title'][0].replace(/[^\w\s]/gi, '').toLowerCase().split(/\s+/) : [];

                // Year as a string
                let yearString = getYear(item.issued).toString();

                // Extract DOI from the query using regex
                const doiRegex = /\b10\.\d{4,}(?:\.\d+)*\/\S+\b/;
                const queryDOI = query.match(doiRegex) ? query.match(doiRegex)[0] : '';

                // DOI from the item
                let doiString = item.DOI ? item.DOI.toLowerCase() : '';
                // Count matches for title words
                let titleMatchCount = 0;
                titleWords.forEach(word => {
                    if (queryWordSet.has(word)) {
                        titleMatchCount++;
                    }
                });
                // Count matches for author surnames
                let authorMatchCount = 0;
                authorSurnames.forEach(word => {
                    if (queryWordSet.has(word)) {
                        authorMatchCount++;
                    }
                });
                // Count matches for journal words
                let journalMatchCount = 0;
                journalWords.forEach(word => {
                    if (queryWordSet.has(word)) {
                        journalMatchCount++;
                    }
                });
                // Check if year matches
                let yearMatchCount = queryWordSet.has(yearString) ? 1 : 0;
                // Check if DOI matches
                let doiMatchCount = (queryDOI && queryDOI === doiString) ? 1 : 0;
                // Logging counts

                // Calculate match percentages for each component
                let titleMatchPercentage = (titleMatchCount / titleWords.length) * title_weight;
                let authorMatchPercentage = (authorMatchCount / authorSurnames.length) * author_weight;
                let journalMatchPercentage = (journalMatchCount / journalWords.length) * journal_weight;
                let yearMatchPercentage = yearMatchCount * year_weight;
                let doiMatchPercentage = doiMatchCount * doi_weight;
                // Combine match percentages
                var matchPercentage = Math.round(titleMatchPercentage + authorMatchPercentage + journalMatchPercentage + yearMatchPercentage + doiMatchPercentage);

                return matchPercentage;
            }

            function formatAuthors_Surname(authors) {
                if (!authors || authors.length === 0) {
                    return '';
                }
                return authors.map(author => `$${author.family}`).join(', ');
            }

            function formatAuthors(authors) {
                if (!authors || authors.length === 0) {
                    return '';
                }
                return authors.map(author => {
                    const givenNameInitial = author.given ? `${author.given[0]}.` : '';
                    return `${givenNameInitial} ${author.family}`;
                }).join(', ');
            }

            function getYear(issued) {
                if (!issued || !issued['date-parts'] || !Array.isArray(issued['date-parts']) || !issued['date-parts'][0] || !Array.isArray(issued['date-parts'][0])) {
                    return 'Unknown Year';
                }
                return issued['date-parts'][0][0] || 'Unknown Year';
            }

        });













    </script>
</body>
</html>
